  this._skipLevelOfDetail = this.skipLevelOfDetail && !defined(this._classificationType) && !this._disableSkipLevelOfDetail && !this._allTilesAdditive;

如果已经 allTilesAdditive 则没必要lod了



L / distance

1. 值越小 distance越大 同样视角对应的height必须代表更多的像素， 当前拉伸越大

maxGeometricError * (height/sseDenominator) / distance 

2. fov 不变， 如果fov变大，需要代表更多的像素，如果没有给的话 意味着值变小，拉伸变大

3. 如果distance 减小，而分辨率不变，意味着height只需代表更少的像素，如果height不变，则error变小

   当前地图总像素数升高，（你不认为升高就是对图片压缩？）

4. 实际上当distance变小，height会变小，

5. 看下这个值跟谁比较 影响lod的

前面改变了state

后面判断computeTileVisibility 方法？







// {

​            //  "boundingVolume": {

​            //      "box": [

​            //          -2394412.079248817,

​            //          5385611.00726511,

​            //          2429621.413888872,

​            //          63.91327089816332,

​            //          0,

​            //          0,

​            //          0,

​            //          64.93723036628217,

​            //          0,

​            //          0,

​            //          0,

​            //          101.67086941469461

​            //      ]

​            //  },

​            //  "geometricError": 0.09,

​            //  "refine": "REPLACE",

​            //  "content": {

​            //      "boundingVolume": {

​            //          "box": [

​            //              -2394402.9929878116,

​            //              5385600.410548152,

​            //              2429638.292451738,

​            //              40.52598871057853,

​            //              0,

​            //              0,

​            //              0,

​            //              43.743796452879906,

​            //              0,

​            //              0,

​            //              0,

​            //              67.913743683137

​            //          ]

​            //      },

​            //      "url": "data/data1.b3dm"

​            //  },

​            //  "children": []

​            // },

​            // {

​            //  "boundingVolume": {

​            //      "box": [

​            //          -2394523.444134842,

​            //          5385568.5612172,

​            //          2429590.172268306,

​            //          50.238214747048914,

​            //          0,

​            //          0,

​            //          0,

​            //          46.23513533733785,

​            //          0,

​            //          0,

​            //          0,

​            //          64.45906504523009

​            //      ]

​            //  },

​            //  "geometricError": 0.04,

​            //  "refine": "REPLACE",

​            //  "content": {

​            //      "boundingVolume": {

​            //          "box": [

​            //              -2394523.444134842,

​            //              5385568.5612172,

​            //              2429590.172268306,

​            //              50.238214747048914,

​            //              0,

​            //              0,

​            //              0,

​            //              46.23513533733785,

​            //              0,

​            //              0,

​            //              0,

​            //              64.45906504523009

​            //          ]

​            //      },

​            //      "url": "data/data5.b3dm"

​            //  }

​            // }









1992 1665

 2000 1715   box对计算的error值貌似没有影响



0612 调试

1. x: -2849813.692887028     (camera 位置)
2. y: 4658978.742858161
3. z: 3283407.8969906056

transfer

-2849807.4296980603,

​      4658972.042051357,

​      3283413.613282441,

减法之后

-6.26318896795

6.700806804

-5.71629183553

debug box位置

1. x: -2849817.3691991013
2. y: 4658985.555053789
3. z: 3283424.3520142986

1. halfAxes: Matrix3

2. 1. 0: -0.426532612685719
   2. 1: -0.2609021470120442
   3. 2: 0
   4. 3: 0.13509368997916166
   5. 4: -0.22085622983204625
   6. 5: 0.42775252269529446
   7. 6: -0.010991333295606214
   8. 7: 0.01796904380115365
   9. 8: 0.012749042380724107

------------------------------------------------



矩阵变换是为了旋转平移





